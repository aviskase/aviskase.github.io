<!doctype html><html lang=en prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#"><head><title>API Testing in Python: requests vs bravado | aviskase</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta property="og:title" content="API Testing in Python: requests vs bravado"><meta property="og:description" content="Note
This article is written as a result of collaboration with TestProject. While many of you know me as a GUI-driven tools hater, that&rsquo;s just my preference, so if something works for you and your company, that&rsquo;s the only thing that matters. There are no best practices and there are no best tools for everyone."><meta name=description content="Note
This article is written as a result of collaboration with TestProject. While many of you know me as a GUI-driven tools hater, that&rsquo;s just my preference, so if something works for you and your company, that&rsquo;s the only thing that matters. There are no best practices and there are no best tools for everyone."><meta property="og:url" content="https://www.aviskase.com/articles/2020/02/07/api-testing-in-python-requests-vs-bravado/"><link rel=canonical href=https://www.aviskase.com/articles/2020/02/07/api-testing-in-python-requests-vs-bravado/><meta property="og:type" content="article"><meta property="og:image" content="https://www.aviskase.com/articles/2020/02/07/api-testing-in-python-requests-vs-bravado/feature.png"><meta property="og:image:height" content="630"><meta property="og:image:width" content="1200"><meta property="article:published_time" content="2020-02-07T23:40:44+00:00"><meta property="article:modified_time" content="2020-02-07T23:40:44+00:00"><meta property="og:site_name" content="aviskase"><meta property="article:author" content="https://www.aviskase.com/pages/about/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.aviskase.com/articles/2020/02/07/api-testing-in-python-requests-vs-bravado/feature.png"><meta name=twitter:title content="API Testing in Python: requests vs bravado"><meta name=twitter:description content="Note
This article is written as a result of collaboration with TestProject. While many of you know me as a GUI-driven tools hater, that&rsquo;s just my preference, so if something works for you and your company, that&rsquo;s the only thing that matters. There are no best practices and there are no best tools for everyone."><meta name=twitter:site content="@aviskase"><link rel=icon href=/theme/img/favicon.ico><link rel=stylesheet href=//code.cdn.mozilla.net/fonts/fira.css><link rel=stylesheet type=text/css href=/theme/css/fontello.css><link rel=stylesheet type=text/css href=/theme/css/style.css></head><body id=index class=home><nav><ul><li><a class=site-title href=/>aviskase</a></li><li><a href=/>Blog</a></li><li><a href=/pages/about/>About</a></li><li><a href=/feeds/all.atom.xml>RSS</a></li></ul></nav><main><article><h1>API Testing in Python: requests vs bravado</h1><div class=article-meta><time class=published>7 Feb 2020</time>
<span class=readtime><span class=icon-clock aria-hidden=true></span>7&nbsp;mins</span></div><div class="admonition note"><p class=admonition-title>Note</p><p>This article is written as a result of collaboration with <a href=https://testproject.io/>TestProject</a>.
While many of you know me as <a href=https://www.aviskase.com/articles/2019/11/25/why-i-dont-use-postman/>a GUI-driven tools hater</a>,
that&rsquo;s just my preference, so if something works for you and your company, that&rsquo;s the only thing
that matters. There are no best practices and there are no best tools for everyone.</p><p>What I really admire the TestProject team for is their strategy of creating a knowledge-sharing community.
And their product has a totally free usage tier. You don&rsquo;t see such combo often.</p></div><p>API testing is not an uncommon topic and you can find a gazillion of articles about it. If you check tutorials in
Java or JavaScript, you’ll notice that they use a plethora of diverse libraries. Yet for Python
<a href=https://www.dowen.me.uk/Automated-rest-api-testing-with-python/ class=external>tutorials</a> are usually based on general-purpose
<a href=https://requests.kennethreitz.org class=external>requests</a> library. In this article, I would like to suggest a different approach.</p><p>Warning: all code examples are written and checked in Python 3.7.
<a href=https://github.com/aviskase/testproject-api-example class=external>You can find the source code here</a>.</p><p>TestProject has an API based <a href=https://api.testproject.io/docs/v2/ class=external>on OpenAPI 2.0 specification</a>.
I’ll use it as an example. If you want to try yourself, don’t forget to create an API key!</p><p>Let’s start with the plain old <em>requests</em> first. But before diving into coding, I suggest <strong>thinking</strong> about what your
framework should be capable of. Don’t spend too much time on the design though, premature overengineering is harmful.</p><p>TestProject API is structured around different resources and methods. For example, to get information about a specific
project you should use <code>projects/{identifier}</code> endpoint with method GET. You’ll probably soon get tired writing
<code>request.get(&lt;params>)</code> all the time, so let’s create a custom function (or method).</p><p>The next commonly used piece is authorization. All calls to API require <code>Authorization</code> header with your API key.
But sometimes you want to pass additional headers, so your framework should support that as well.</p><p>This is an example class I wrote:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> requests


<span style=color:#ff79c6>class</span> <span style=color:#50fa7b>APITestProject</span>:
    endpoint <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;https://api.testproject.io/v2&#39;</span>
    auth_headers <span style=color:#ff79c6>=</span> {}

    <span style=color:#ff79c6>def</span> __init__(self, api_key<span style=color:#ff79c6>=</span>None):
        <span style=color:#6272a4># Sometimes we don&#39;t want to authorize requests</span>
        <span style=color:#ff79c6>if</span> api_key:
            self<span style=color:#ff79c6>.</span>auth_headers <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#39;Authorization&#39;</span>: api_key}

    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>_construct_headers</span>(self, headers):
        <span style=color:#6272a4># Allows to combine authorization header with per-request custom headers</span>
        <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>isinstance</span>(headers, <span style=color:#8be9fd;font-style:italic>dict</span>):
            <span style=color:#ff79c6>return</span> {<span style=color:#ff79c6>**</span>self<span style=color:#ff79c6>.</span>auth_headers, <span style=color:#ff79c6>**</span>headers}
        <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>auth_headers

    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>get_specific_project</span>(self, identifier, headers<span style=color:#ff79c6>=</span>None):
        <span style=color:#ff79c6>return</span> requests<span style=color:#ff79c6>.</span>get(f<span style=color:#f1fa8c>&#39;{self.endpoint}/projects/{identifier}&#39;</span>, headers<span style=color:#ff79c6>=</span>self<span style=color:#ff79c6>.</span>_construct_headers(headers))

</code></pre></div><p>Now it’s time to write simple tests. I use <em>pytest</em> as a test runner because of its versatility and pluggability.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> pytest

<span style=color:#ff79c6>from</span> requests_client.api_testproject <span style=color:#ff79c6>import</span> APITestProject


@pytest.fixture(scope<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;module&#39;</span>)
<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>api</span>(api_key):
    <span style=color:#ff79c6>return</span> APITestProject(api_key)


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_specific_project</span>(api, existing_project):
    response <span style=color:#ff79c6>=</span> api<span style=color:#ff79c6>.</span>get_specific_project(existing_project)
    <span style=color:#ff79c6>assert</span> response<span style=color:#ff79c6>.</span>status_code <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>200</span>


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_nonexisting_project</span>(api):
    response <span style=color:#ff79c6>=</span> api<span style=color:#ff79c6>.</span>get_specific_project(<span style=color:#f1fa8c>&#39;iZyZmrbAAkuHyqdB3O6fHd&#39;</span>)
    <span style=color:#ff79c6>assert</span> response<span style=color:#ff79c6>.</span>status_code <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>404</span>


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_specific_project_accept_html</span>(api, existing_project):
    response <span style=color:#ff79c6>=</span> api<span style=color:#ff79c6>.</span>get_specific_project(existing_project, headers<span style=color:#ff79c6>=</span>{<span style=color:#f1fa8c>&#39;Accept&#39;</span>: <span style=color:#f1fa8c>&#39;text/html&#39;</span>})
    <span style=color:#ff79c6>assert</span> response<span style=color:#ff79c6>.</span>status_code <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>406</span>

</code></pre></div><p>If you are not familiar with pytest fixtures, you can read about them in
<a href=https://docs.pytest.org/en/latest/fixture.html class=external>the official documentation</a>. In short, here I have three fixtures:</p><ul><li><code>api_key</code> — defined in <code>conftest.py</code> and returns a string with my API key</li><li><code>existing_project</code> — defined in <code>conftest.py</code> and returns a string with id of one of my project</li><li><code>api</code> — constructs a default client for API using an API key</li></ul><p>Tests are pretty straightforward:</p><ul><li>Retrieve information about the existing project.</li><li>Attempt to get information using non-existing project id.</li><li>Attempt to retrieve information about the existing project while asking to send information in the HTML format.</li></ul><p>They assert only responses’ status codes (not the best tests ever). But take a look at the last test. At the time
of writing the only officially supported response content types were: <code>application/json</code>, <code>text/json</code>, <code>text/plain</code>, and
<code>application/json-patch+json</code>. Though, if you take a careful look at the description doc, you’ll notice that
<code>application/xml</code> is supported too. Anyway, with <code>Accept: text/html</code> you’d expect server to respond with
<code>406 Not Acceptable</code>. Yet, that’s not the case: the current version responds with 200 code and plain text json body.
It&rsquo;s not a serious issue, but it&rsquo;s worth exploring because it means that there are places where server capabilities
don&rsquo;t match the published description doc. I suspect it&rsquo;s a sign of a design-first approach (which I like!), but it can
be hard to manage.</p><p>As you noticed, for creating API tests using requests library we need to write a lot of boilerplate code:</p><ul><li>Wrappers for headers and query string managements.</li><li>Methods/functions written in business terms rather than GET/POST/etc way.</li><li>Constructing endpoints path (concatenating the main URL with paths, ids, and query parameters).</li></ul><p>Basically, you create a whole API client. And we haven’t even touched data models. Oh, if only this could be
simplified and automated, right? And it can! Welcome to the brave <em>old</em> world of client generation based on API
description docs. TestProject doesn&rsquo;t just provide endpoints but also has a description doc to describe their API.
Currently, it’s based on Open API 2.0, or, as many people still call it, Swagger. This description doc is used to
generate a documentation UI with &ldquo;Try out&rdquo; capabilities, and it also can be used for client generation. Personally, I
ended up using <a href=https://github.com/Yelp/bravado class=external>bravado</a> library for this task.</p><p>Here is how our small class will look with bravado:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> json
<span style=color:#ff79c6>from</span> pathlib <span style=color:#ff79c6>import</span> Path

<span style=color:#ff79c6>from</span> bravado.client <span style=color:#ff79c6>import</span> SwaggerClient
<span style=color:#ff79c6>from</span> bravado.requests_client <span style=color:#ff79c6>import</span> RequestsClient


<span style=color:#ff79c6>class</span> <span style=color:#50fa7b>APITestProject</span>:
    host <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;api.testproject.io&#39;</span>
    swagger_spec <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;https://api.testproject.io/docs/v2/swagger.json&#39;</span>
    swagger_file <span style=color:#ff79c6>=</span> Path(__file__)<span style=color:#ff79c6>.</span>parent <span style=color:#ff79c6>/</span> <span style=color:#f1fa8c>&#39;swagger.json&#39;</span>

    <span style=color:#ff79c6>def</span> __init__(self, api_key<span style=color:#ff79c6>=</span>None):
        http_client <span style=color:#ff79c6>=</span> RequestsClient()
        <span style=color:#ff79c6>if</span> api_key:
            http_client<span style=color:#ff79c6>.</span>set_api_key(self<span style=color:#ff79c6>.</span>host, api_key, param_name<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;Authorization&#39;</span>, param_in<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;header&#39;</span>)
        <span style=color:#6272a4># Usually I&#39;ll use `from_url` generation, but current version of specification is not valid OpenAPI 2.0</span>
        <span style=color:#6272a4># self.client = SwaggerClient.from_url(self.swagger_spec, http_client=http_client)</span>
        swagger_spec <span style=color:#ff79c6>=</span> json<span style=color:#ff79c6>.</span>load(self<span style=color:#ff79c6>.</span>swagger_file<span style=color:#ff79c6>.</span>open())
        self<span style=color:#ff79c6>.</span>client <span style=color:#ff79c6>=</span> SwaggerClient<span style=color:#ff79c6>.</span>from_spec(swagger_spec, http_client<span style=color:#ff79c6>=</span>http_client)

</code></pre></div><p>There are two ways to generate a client with bravado: pointing either to URL where description doc is hosted or to
the local file. The example uses local file because bravado doesn&rsquo;t just simply generate client, but also can
perform validation, and unfortunately at the time of writing TestProject API description doc contains some invalid
attributes. But that’s a great thing! Even though developers should be using linters to check for such problems, it
is still a good idea to recheck during integration tests. Another nice feature is that bravado performs requests and
response validation, which can help find dynamic problems. For example, if the description doc says that the field in
the response should be an integer, yet you received a string, you’ll get an exception even if there were no explicit
assertions for that field in the test. Of course, you can disable all validations, though, I wouldn&rsquo;t recommend that.</p><p>So, let’s go back to the tests and see how they look with bravado based client:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> pytest
<span style=color:#ff79c6>from</span> bravado.exception <span style=color:#ff79c6>import</span> HTTPNotFound, HTTPNotAcceptable

<span style=color:#ff79c6>from</span> bravado_client.api_testproject <span style=color:#ff79c6>import</span> APITestProject


@pytest.fixture(scope<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;module&#39;</span>)
<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>api</span>(api_key):
    <span style=color:#ff79c6>return</span> APITestProject(api_key)<span style=color:#ff79c6>.</span>client


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_specific_project</span>(api, existing_project):
    response <span style=color:#ff79c6>=</span> api<span style=color:#ff79c6>.</span>Projects<span style=color:#ff79c6>.</span>Projects_GetProject(projectId<span style=color:#ff79c6>=</span>existing_project)<span style=color:#ff79c6>.</span>response()
    <span style=color:#ff79c6>assert</span> response<span style=color:#ff79c6>.</span>metadata<span style=color:#ff79c6>.</span>status_code <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>200</span>


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_nonexisting_project</span>(api):
    <span style=color:#ff79c6>with</span> pytest<span style=color:#ff79c6>.</span>raises(HTTPNotFound):
        api<span style=color:#ff79c6>.</span>Projects<span style=color:#ff79c6>.</span>Projects_GetProject(projectId<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;iZyZmrbAAkuHyqdB3O6fHd&#39;</span>)<span style=color:#ff79c6>.</span>response()


<span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_get_specific_project_accept_html</span>(api, existing_project):
    <span style=color:#ff79c6>with</span> pytest<span style=color:#ff79c6>.</span>raises(HTTPNotAcceptable):
        api<span style=color:#ff79c6>.</span>Projects<span style=color:#ff79c6>.</span>Projects_GetProject(
            projectId<span style=color:#ff79c6>=</span>existing_project,
            _request_options<span style=color:#ff79c6>=</span>{<span style=color:#f1fa8c>&#39;headers&#39;</span>: {<span style=color:#f1fa8c>&#39;Accept&#39;</span>: <span style=color:#f1fa8c>&#39;text/html&#39;</span>}}
        )<span style=color:#ff79c6>.</span>response()

</code></pre></div><p>Did you notice magic there? I don’t need to write code with GETs anymore. Bravado generates resources and methods
for them automagically. Usually, they are based on tag and <code>operationId</code>, so for getting a specific project:
<code>tag=Projects</code> and <code>operationId=Projects_GetProject</code>. Another difference is that bravado throws an exception if the
response code is not 2xx. In my view, <code>HTTPNotAcceptable</code> is more readable than a number 406.</p><p>Now it’s time to check how using client generation library helps to improve on a barebone approach with requests:</p><ul><li>No need for custom headers and query string management, it’s already written by library developers.
With bravado you can have default headers for each request as well as per request custom headers.</li><li>Methods/functions are generated and sound more domain-specific (though, it depends on how accurate was
naming of operationIds).</li><li>The only endpoint you should worry about is where the description doc is hosted, or, if using the local file,
the <code>host</code> attribute.</li></ul><p>Don’t forget, all magic comes with a price. Client generators are not perfect for everyone:</p><ul><li>Autogeneration is useless for constantly changing APIs. Though, it’s considered a bad practice,
because real customers also use client generators and each breaking change is a pain for them.</li><li>Sometimes you want to make invalid requests. In some cases, you can simply turn off request validation,
but usually making real fuzzy tests is easier with general-purpose HTTP libraries.</li><li>Not your code. There could be bugs. Be careful when selecting a library, it’s better to be open source with
fresh contributions. Also, pay attention to supported specifications: bravado does not support OpenAPI 3.0 =(</li></ul><p>The world of API related tools and libraries is enormous. Some people prefer GUI-driven tools like Postman or
TestProject, others prefer to code. Next time you’ll be writing automation, don’t feel restricted to common generic
libraries and consider different alternatives.</p><div class="page-navigation code"><a class=prev href=https://www.aviskase.com/articles/2020/02/01/hmms-january/ title="Hmms: January">&larr; older</a>
<span>&nbsp; &#183; &nbsp; &#183; &nbsp; &#183; &nbsp;</span>
<a class=next href=https://www.aviskase.com/articles/2020/03/08/hmms-february/ title="Hmms: February">newer &rarr;</a></div></article></main><footer><a href=mailto:aviskase@gmail.com>Yuliya Bagriy</a><span> &#183; 2020 &#183; </span><a href=https://www.aviskase.com/pages/i-dont-track-you/>No tracking</a></footer></body></html>