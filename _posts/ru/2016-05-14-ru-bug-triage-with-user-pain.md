---
title: Сортировка дефектов по боли
ref: 160514
lang: ru
translation: true
---
Перевод статьи [Improving Bug Triage with User Pain](http://www.lostgarden.com/2008/05/improving-bug-triage-with-user-pain.html)<span class="tag tag-lang">en</span> от Daniel Cook.

Не являюсь хорошим переводчиком, поэтому заранее прошу прощения. Но так как я не видела нигде перевода на русский, то может мой, пусть и дурацкий, перевод кому-то пригодится.

---

Традиционный процесс приоритизации дефектов страшно неэффективен. За десять лет работы я потратил месяцы моей жизни сидя в безоконных офисах вручную проверяя (и перепроверяя) тысячи багов. Чаще всего в триажной группе нас было трое или четверо, обычно самые опытные ребята в команде, которые сидели и часами спорили о тонкостях неоднозначных багов. Подтасовка, скука и необоснованные решения были увы распространены. В результате --- потраченное в пустую время и плохо управляемые дефекты.

Поэтому мы придумали кое-что получше.

На протяжении многих релизов и в разных командах я пользуюсь техникой "боль[[Прим.: возможно звучит коряво, но мне нравится простор словоформ этого корня]] пользователя". Она заключается в том, что бы сортировать баги по однозначной унифицированной шкале "боль пользователя", которая учитывает несколько типичных критериев ранжирования дефектов. На мой взгляд эта техника позволяет снизить затраты на приоритизацию, помочь команде выпускаться вовремя и вносит ясность, какие баги нужно исправлять прямо сейчас. Данная статья описывает как работает эта техника и как можно её применить в вашей команде.


## Проблемы с обычной приоритизацией
Типичный процесс приоритизации дефектов занимает много времени и крайне утомителен. Дефекты заводятся в систему с кое-как выставленными приоритетами, тим-лиды сортируют и классифицируют каждую проблему, а потом назначают на подходящих членов команды. Такой процесс ведёт к нескольким последствиям:

* *Отсутствие общих критериев.* Разные люди обращают внимание на разные аспекты дефектов, что приводит к разногласиям. Дизайнер может считать критичной проблему с юзабилити, тогда как разработчика больше волнуют сбои. Без общих критериев оценки сложно быстро прийти к согласию.
* *Потерянное время.* Обычно приоритизацией занимаются самые опытные ребята. Они тратят гигантское количество времени обдумывая рутинные дефекты снова и снова. То время, которое могло бы быть использовано на улучшение продукта. 
* *Узкие места.* Часто требуется, что бы дефекты кто-то проверил, прежде чем они дойдут до разработчика, что бы не тратить его драгоценное время. Из-за этого путь от того, кто завёл критический дефект, до того, кто его будет исправлять, может заметно увеличиться по времени. 
* *Груды неразличимых багов.* Так как темп поступления багов чаще всего выше чем темп фикса, у каждого разработчика скапливаются кучи дефектов. Если на разработчике висит 50 багов, то он/она будет фиксить их в случайном порядке либо надеяться на дотошный менеджмент триажной группы. В первом случае есть вероятность, что критические баги будут исправлены в самом конце. Во втором случае ещё больше времени будет потрачено на приоритизацию.
* *Выгорание команды.* После проверки тысячи багов триажные группы перестают заботиться о качестве процесса или наоборот уделяют слишком много внимания только части дефектов, пропуская другие. В результате у некоторых дефектов плохо проставлены приоритеты и страдает качество сортировки довольно.

Эти проблемы мы постараемся решить с помощью оценки боли пользователя.

## Суть техники
Техника боли пользователя зародилась на основе идей Lean Manufacturing, бабушкой многих практик в Agile. Техника была разработана в 80-х как метод эффективной классификации дефектов на производственных линиях. Некоторые идеи новы для сферы разработки ПО, однако ключевые моменты проверены на производствах уже десятки лет. 

Как и многие другие техники Agile, понять, как оценить боль пользователя, не сложно:

1. Оценить каждый баг по нескольким критериям
2. Соединить оценки в одну, называемую "боль пользователя"
3. Отсортировать все дефекты по боли в общедоступном списке
4. Начать исправлять самые болевые дефекты сверху списка

Философия здесь простая. Первое, дать возможность заводить дефекты, которые хорошо сформированы и поддаются классификации. Следующее, дать команде необходимые средства и информацию для принятия решения о том, что нужно делать в первую очередь. Наконец, команде будет проще работать на качество. Вместо упования на менеджеров, можно быть уверенными в решениях самой команды. В результате пропадает почти вся необходимость в посреднике --- триажной группе.

Давайте подробнее рассмотрим каждый шаг.

## Шаг 1: оценить каждый баг по нескольким критериям
На странице заведения дефекта должны быть представлены три фактора: тип, вероятность и приоритет. Каждый фактор несёт несколько значений, перечисленных в порядке увеличения степени последствий. Оценка проставляется в момент заведения дефекта.

### Три фактора оценки
Вот три фактора, которые использую я:

* *Тип.* Какого типа этот дефект? Например, это сбой, проблема с локализацией или вёрсткой?
* *Вероятность.* Насколько вероятно что пользователи обнаружат дефект? Например, все или только часть пользователей? 
* *Приоритет.* Из тех людей, которые обратят внимание на проблему, насколько сильно это повлияет на их мнение о продукте? 

Конкретно эти факторы были проверены уже на многих релизах и были выбраны по следующим причинам:

* *Хорошее покрытие.* Заинтересованных сторон много, и их могут волновать разные аспекты. Данные факторы покрывают большинство их них. Тип определяет бизнес направленность, тогда как вероятность и приоритет помогают понять воздействие на пользователя. 
* *Не перекрываются (aka ортогональные).* Оценка бага по одному фактору не влияет на оценки по другим. Возможность оценивать факторы в изоляции друг от друга повышает объективность результата. 
* *Малое число.* Их достаточно мало что бы не запутаться при заведении дефекта. Можно с лёгкостью добавить ещё факторов, что бы покрыть пограничные случаи, но форма заведения багов станет сложной и непонятной. 

### Использование фиксированной шкалы
Теперь, когда мы определились с факторами, каждому нужно определить фиксированную шкалу. Каждое очко на шкале соотносится с объективным описанием. Вот шкала, которая нравится мне:

*Тип* (Какого типа этот баг?)

1. Документация: проблемы в документации.
2. Локализация: проблемы с локализацией.
3. Шлифовка визуальной и звуковой составляющих: эстетические проблемы
4. Регулирование: позволяет выполнять опасные действия, которые вредят взаимодействию с продуктом.
5. Незначительная проблема: мешает прохождению второстепенных сценариев.
6. Значительные проблема: мешает прохождению ключевых сценариев.
7. Сбой: баг вызывает сбой или потерю данных.

*Приоритет* (Как скажется баг на пользователе?)

1. Неприятность --- ничего особенного, но можно заметить. Влияние на продажи маловероятно.
2. Боль --- пользователь будет раздражён. Некоторое количество людей откажется от покупки.
3. Пользователь скорее всего не купит продукт. Будет упомянуто в обзорах. Очень заметная проблема.
4. Пользователь вернёт продукт. Релиз нельзя использовать как финальную версию. Команда отложит релиз из-за этого бага.
5. Блокирует дальнейшие сборки.

*Вероятность* (Кто будет затронут багом?)

1. Почти никто.
2. Только некоторые пользователи.
3. Половина пользователей.
4. Большинство пользователей.
5. Все пользователи.

Фиксированная шкала описывает каждое очко на шкале конкретными, объективными критериями. До тех пор пока все элементы, которые нужно оценить, подходят под один из критериев, вы всегда знаете какое значение нужно выбрать. Фиксированная шкала предпочтительней относительной (напр., оцените проблему от 1 до 10) т.к. она менее субъективна.

### Добавить фиксированную шкалу на видное место туда, где заводят дефекты
Фиксированные шкалы полезны только тогда, когда команда видит их описания.

Для одной команды мы только отображали цифры от 1 до 5 в выпадающем списке и требовали помнить, что каждая цифра означает. Это было не очень эффективно. Люди трактовали факторы как относительные шкалы и оценивали их по тому как ощущали, а не по реальным определениям каждого значения. В итоге оценки были слишком зависимы от личных убеждений. 

Поэтому лучше использовать такую форму заведения дефектов, где человек может прочитать описание каждого значения в процессе оценки дефекта. Например, можно использовать радио кнопки. Выпадающий список, содержащий описания, тоже подойдёт.

Может показаться что это мелочь, но люди обычно спешат. Если процесс оценки будет слишком затруднён, то они без зазрения совести отметят первое что попадётся. Понятность формы заведения дефектов --- это простейший способ улучшить их качество. 

### Кто заводит баги
Такая система направлена на использование всеми членами команды. Дизайнеры, тестировщики, разработчики, менеджеры --- у всех должно быть понимание критериев и возможность заведения сразу оценённых дефектов. Они должны понимать ключевые сценарии и конечного пользователя. Чем лучше вы объясните команде что вы делаете и для кого, тем качественнее будут ваши баги.

Для внешних пользователей система хорошо работать не будет. Они не понимают терминологию и обычно плохо описывают проблемы. Лучшим решением будет давать тестировщику заводить обращения пользователей с уже правильным форматом и оценкой. Это можно назвать формой приоритизации, но в целом стоит гораздо меньше.

### Выгоды
Использование фиксированной шкалы оценки дефектов приносит следующие выгоды:

* *Меньше зависимость от субъективного мнения.* Тестировщик, который имеет представление о предметной области, может быстро определить категорию дефекта не полагаясь на личное мнение. Даже если дать нескольким людям независимо оценить один и тот же баг, финальная оценка будет примерно совпадать. 
* *Тяжелее обмануть систему.* Фиксированные шкалы не дают быстро подогнать оценку для бага. Так как критерии достаточно ясны, плохо оценённые дефекты легко распознает первый же человек, который его увидит.
* *Приоритизация сразу при заведении.* Процесс приоритизации становится проще, когда вы можете доверить оценку тем, то заводит дефекты. Если у человека есть базовое представление о предметной области, 80-90% проставляемых оценок не будет меняться на протяжении существования дефекта. Поэтому потребность в дополнительных проверках меньше.  

## Шаг 2: соединить критерии в одну оценку "боль пользователя"
Как только баг оценён по всем трем факторам, нужно перемножить числа что бы получить оценку боли. Боль пользователя --- это одно значение, которое можно использовать для сравнения различных дефектов. Она позволяет выявить такие дефекты как:

* *Очевидный фикс:* баг, который пользователь возненавидит, который блокирует основные сценарии использования и влияет на всех. Поэтому он получит очень высокую оценку боли.
* *Неочевидная проблема:* баг, который возникает постоянно. Несмотря на то, что он блокирует только второстепенные сценарии, оценка боли будет относительно высокой.
* *Заковыристая ошибка:* сбой, который никому не будет заметен, получит малую оценку.

Основная формула вычисления боли пользователя такая:

$$Боль = \frac{Тип \cdot Вероятность \cdot Приоритет}{МаксимальнаяОценка}$$

Боль вычисляется автоматически в момент заведения дефекта и каждый раз, когда он изменяется. После того как вы посчитаете боль для некоторого множества багов, у вас получится однородный диапазон с болью от 1 до 100%.

### Выгоды

* *Одно значение для сравнения разных дефектов.* Вместо того, что бы пытаться понять разные критерии при сравнении багов, нужно посмотреть только на одну итоговую оценку. А это значит, что решения принимаются быстрее, и сортировка становится проще. 
* *Больший диапазон приоритетов.* Теперь не нужно работать с кучей неразличимых дефектов. Вместо 300 багов с приоритетом 2, будут маленькие управляемые кучки в 3 или 5 дефектов с одинаковой болью. Зрелость багов, которая описана в приложении, так же позволяет распределить дефекты.

## Шаг 3: отсортировать все баги по боли в общедоступном списке
Как только у вас появился список дефектов с подсчитанной болью, его необходимо предоставить команде в удобном форме. Я пробовал различные хитрые выборки в системах управления дефектами, но больше всего мне нравится моя простейшая в мире доска под названием "болелист". 

### Болелист
Болелист --- страница, на которой представлены все актуальные баги в порядке уменьшения боли пользователя. Самые болевые дефекты идут наверх списка и для каждого есть ссылка на страницу в базе дефектов. Важно часто обновлять список, например, каждые 10 секунд.

![Пример болелиста]({{ site.url }}/assets/images/pain_list.png)

Болелист --- ключевой момент в ежедневном управлении дефектами. У меня он даже назначен домашней страницей в браузере. 

### Планки качества
Команда может использовать болелист что бы определить планки качества, которые можно использовать как выходной критерий выпуска. Например, "что бы выпустить релиз, нам нельзя иметь дефекты с болью выше 30". На этой планке проводится черта в болелисте. Всё что выше этой линии должно быть исправлено. Всё что ниже --- допустимо в релизе.

Планки качества могут быть более демонстративны чем традиционное количество дефектов, так как учитывается влияние на конечного пользователя. Соответствие определённой планке означает что вы исправили все сбои и неприятные дефекты и остались только незначительные косметические проблемы, на которые пользователи не обратят внимание.

Так как спектр дефектов стал более широк, вы можете более точно определять планку качества в зависимости от важности текущего релиза. Можно поставить высокую планку если ведётся работа над новыми фичами. Можно сделать её ещё выше в последующих релизах.

### Выгоды
* *Одна точка входа.* Один список доступный всем, включая тестировщиков и  разработчиков. Не нужно беспокоиться об управлении разными фильтрами. 
* *Легко понять всем заинтересованным лицам.* Нет сложных методов и непонятных графиков. Даже менеджеры могут понять как обстоят дела просто взглянув на список. 
* *Чёткое понимание статуса.* Если есть баги выше планки качество, то нужно начать их исправлять.

## Шаг 4: начать исправлять самые болевые баги сверху списка
Теперь, когда у нас есть болелист, его нужно использовать. Разработчики ежедневно просматривают список и правят дефекты с наибольшей болью. Если не осталось багов выше текущей планки качества, можно продолжить работу над новой функциональность. Эвристика очень проста и удивительно эффективна для управления качеством.

### Назначение дефектов на исполнителя
Все дефекты определяются как актуальные на момент заведения и не назначаются на кого-то определённого. Когда разработчик видит болевой баг, над которым хочет поработать, он назначает его на себя. Дальше баг идёт через стандартную процедуру исправления, тестирования и закрытия. В общем, разработчики не должны одновременно иметь больше десятки дефектов на них. Они выбирают элемент из списка, фиксят его и возвращаются за следующим. Чрезмерное накопление не приветствуется.

### Фикс багов до работы над фичами
Все дефекты выше планки качества должны быть исправлены до того, как начнётся работа над новыми фичами. Если следовать этому правилу, то при окончании спринта не должно быть больше сильно болевых багов чем на момент начала спринта. Технический долг не накапливается.

Такая практика позволяет поддерживать качество в процессе разработки. А если подкрепить её ещё и хорошими автоматизированными тестами, то начнётся магия высококачественной разработки.

### Мои баги
Сверху болелиста имеется область, в которой перечислены все дефекты, назначенные на пользователя. Это позволяет использовать болелист как единую точку входа и напоминает, что нужно закончить работу по всем своим дефектам прежде чем браться за новые. Так как список маленький, он редко будет мешать просмотру самого болелиста.

### Выгоды

* *Разработчики всегда знают что исправлять.* Всё что им нужно делать это смотреть на список. В результате разработчикам не требуется прикидывать различные факторы что бы решить, над чем работать дальше. Как и не требуется ждать лидов или менеджеров что бы они назначили дефект.
* *Способствует коллективному владению кодом.* Правило "правь с верха" редко совпадает с "правь код, который написал я". В краткосрочной перспективе это менее эффективно, так как разработчики вероятно будут задавать вопросы автору кода. В долгосрочной перспективе хорошее знание кодовой базы в результате фикса дефектов вне зоны компетенции повышает общую продуктивность и гибкость команды.[[Ажайл ажайлом, но для мега большого проекта возможно и в долгосрочной перспективе --- это боль]]
* *Не накапливаются дефекты, которые мешают выпуску.* Выгоды от исправления дефектов до работы над фичами бесконечны. Проблем в ходе релиза гораздо меньше. Тестирование более эффективно так как не нужно придумывать обходные пути для дефектов, которые не будут исправлены месяцами. Наконец, команда чувствует себя уверенней так как знает что они всегда делают высококачественный продукт.

## Ошибки
Есть несколько ошибок, которые могут возникнуть при первой попытке внедрения техники.

### Обучение команды
Вероятно в вашей команде будут люди, которые годами боролись с багами. Изменения в системе управления дефектами требует переобучения прежде чем получатся хорошие результаты.

По моему опыту, новые команды изначально оценивают 80% дефектов неверно потому что они А) не используют шкалу оценки или Б) не понимают конечного пользователя. Что бы решить эту проблему, удостоверьтесь, что описание фиксированной шкалы оценки легко доступно, и не забывайте доносить до сотрудников информацию о ключевых сценариях и конечном пользователе. После того, как люди оценят пару десятков дефектов, их оценки боли статут достаточно надёжными.

### Соблазн приписать "стоимость фикса"
Вы наверняка заметили что в боли нигде не используется "стоимость" или технический риск исправления ошибки. Этот фактор почти незамедлительно предлагают разработчики. Несмотря на искушение, я предлагаю его не учитывать:

* *Требует дополнительных усилий.* В восьми случаях из десяти разработчикам нужно разобраться в коде что бы понять причину дефекта прежде чем они определят, сколько потребуется времени на фикс. Если требовать определения "стоимости" в момент расчёта боли пользователя, вся система пойдёт на дно.
* *В 99% это не имеет значения.* Стоимость фикса предположительно подчиняется экспоненциальному распределению. Для многих дефектов хватит одной или двух строк изменений. Другие изредка занимают больше нескольких суток. Очень редко случаются настоящие бомбы. Пометьте исключения, а для остальных используйте универсальную скорость фикса и результаты будут так же предсказуемы, как если бы вы оценивали стоимость для каждого бага.

### Соблазн автоматизировать исключения
Техника пользовательской боли создана для автоматизации процесса приоритизации. Всегда есть соблазн автоматизировать всё. Что насчёт 1% багов, которые могут задержать ваше релиз на столетие? Если вы наткнётесь на дефект, которые потребует больше недели на исправление, пометьте его какой-нибудь меткой (например, "бомба"). Бомбы должны быть помечены красным в болелисте и по ним нужно отсылать команде уведомление по почте.

Найти решение --- теперь обязанность лидов. Они могут сделать какие-то архитектурные правки, отсрочить решение, или таки сделать фикс. Раз их освободили от мук приоритизации, у них есть время заняться сложными проблемами с удвоенной силой.

Оценка боли позволяет адекватно воспринимать баги-бомбы. Будут бомбы с очень низкой болью из-за которых не стоит отодвигать время релиза. И будут бомбы с высокой болью, которые серьёзно повлияют на релиз и должны быть исправлены без промедления.

А урок из этого такой. Никогда не пытайтесь построить систему, особенно зависящую от людей, которая бы смогла обрабатывать каждую непредвиденную ситуацию. Чем больше вы будете подстраиваться под каждый пограничный случай, тем менее эффективен будет конечный результат. Вместо этого позвольте самим сотрудникам подымать тревогу, что бы разум, а не формулы, принимал решения по мере поступления проблем.


## Заключение
Техника боли пользователя достаточно проста несмотря на все упомянутые детали. Команда заводит и оценивает дефекты. Система подсчитывает боль и выплёвывает всем свежий список отсортированных дефектов. Команда исправляет баги начиная сверху списка. Это самое основное.

С таким процессом команда процветает. Неопределённость меньше. Не нужно детально контролировать каждый малёхонький дефект (и каждого разработчика). С этой техникой ответственность за качество лежит в руках команды. Они сами приоритизируют баги. Они исправляют самые важные в первую очередь. Процесс предоставляет все средства для принятия правильных решений. Ещё раз, мы говорим о поддержке людей, а не управлении.  

Оценка боли не подойдёт каждой команде. Как и не убирает полностью процесс приоритизации. Если кто-то думает что процесс --- это панацея, то он имеет ещё мало опыта. Тем не менее, при правильном подходе техника боли пользователя является заметным прогрессом по сравнению с просиживанием часами в душной комнате вручную просматривая сотни багов. С ней команда может стать более эффективной, принимать лучшие решения и выпускать высококачественный продукт.

## Приложения

### Зрелость бага
Фиксирование планки качества помогает быстрому фиксу "очень болевых" багов. Однако с течением времени скопятся сотни старых багов с малой болью. А так как процесс "насильственной" приоритизации происходит гораздо реже, само качество заведения этих дефектов может быть достаточно низким.

Что бы решить эту проблему достаточно добавить фактор зрелости бага к оценке боли. За каждый день с момента заведения бага надо прибавлять к оценке 0,2 очка. Со временем старые баги медленно подымятся к самому верху болелиста. Конечно же стоит адаптировать скорость с какой баг будет зреть к тому, что требуется на конкретном проекте.

В результате получается что:

* *Старые баги медленно уходят из системы.* Вы либо решите их не править вообще или исправляете.
* *Небольшие баги медленно фиксятся.* Вместо того, что бы постоянно оставлять небольшие баги в продукте, в конечном итоге вы исправите их, что бы достичь планки качества. Тем самым предотвращается накопление технического долга.

### График появления дефектов

![График появления дефектов]({{ site.url }}/assets/images/tracking_chart.png)

Обычный линейный график, на котором изображено количество багов выше различных планк качества, очень подходит для отслеживания ситуации. Можно сравнивать его с графиком всех заведённых багов. Идеальный тренд --- когда количество багов высокого приоритета быстро уменьшается. Тревожными знаками будет:

* *Слишком много внимания разработке новых фич:* количество багов продолжает увеличиваться.
* *Неправильный приоритет в выборе что фиксить:* общее число уменьшается, но количество багов с высокой болью почти неизменно.

Другие интересные метрики:

* *Общая боль:* суммарный эффект всех багов в системе на пользователя. Некоторые команды используют это как дополнительную оценку могут ли они выпускать релиз или нет. Это ещё один из способов удостовериться, что релиз не будет содержать сотню мелких дефектов, которые вызовут у пользователя значительное раздражение. Данная оценка гораздо показательнее чем просто число дефектов, но имеет схожее назначение.
* *Средняя боль:* позволяет на глаз определить общую нестабильность продукта. Высокая средняя боль, особенно вблизи планки качества, означает что осталось ещё очень много работы.
